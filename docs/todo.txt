Things toppcloud Should Do
==========================

This document lists out things that I think toppcloud should do, but
does not yet do.  It's also kind of a notepad for design ideas.  It
should not surprise you if I forget to remove something from this
document after implementing it.

Long-time expiration of static content
--------------------------------------

It's nice to present static content with far-future expiration dates.
Do do this while still allowing this static content to be updated, it
is conventional to use a timestamp of some sort in the URL itself.  An
example might be::

    /static/20100127_1/media/style.css

Then if the application is updated this URL will change.  You could
use the modification date of the file itself, but a sweeping
invalidation of all content is less error-prone and requires very
little framework support.

I think toppcloud should add a new location (like in the example)
where content in the ``static/`` directory is served with this
caching, and an environmental variable ``$STATIC_URL`` which you use
to prefix all your media files.  Probably the current pattern will be
preserved, as it can be handy when retrofitting an application.

Then in the future there should also be support for uploading these
static files to a CDN, at which point the variable will point to the
CDN.

Groups of servers, replication
------------------------------

This is kind of an obvious feature for toppcloud, being all "cloud"
like.  Instead of hosting things like a database locally, it should be
possible to host it on a central server with many "application"
servers pointing to it.  

And, in turn, it should be possible to use replication or sharding to
have many database servers, though this is more difficult.

Then, though it's largely outside the scope of toppcloud itself, it
should be possible to move frontend (varnish) caching to another
layer, and load balancing around that.  While it might be reasonable
to manage that with toppcloud, nothing toppcloud currently does is
really interested in that layer.

For the first two it will be necessary to add a new concept of a
server group.  This is too big to shove in ``~/.toppcloud.conf`` (and
should probably be version-control-friendly).  I expect a new document
describing server groups will be necessary.

Backups
-------

It should be possible to get a nice backup file of everything, or
upload one to some location.  It would be very nice if backup files
were portable.  Then, for instance, you could download the backups to
replicate live data on your site.

It would be even more neat if backup files were somewhat version
control friendly.  E.g., well-ordered SQL dumps.

Backup restore should also be handled; writing backup code without
restore code is just silly.

Logs
----

Log files should also be handled gracefully, tracked, and possibly
some frontend.  Though I feel like some kind of management interface is
better, and then a "deployed" app would use that interface.  Actually,
"interface" is probably saying too much; documented and conscious
server layout that an application can be written to inspect.

Monitoring
----------

Basically a way is needed to answer the question "do I need to rent
bigger (or smaller) nodes?" Basic metrics like load, RAM, swap and
requets per second should be monitored and graphed. Munin seems to be a
popular choice for that.

Create Virtual Machine Images
-----------------------------

Local development can for some people be quite hard.  This is
especially true of Windows users (for which toppcloud doesn't have any
support, and no support is planned).

It would be nice to be able to run something like:

    toppcloud setup-develop-image .

and have it get a bare Ubuntu image (for VMWare, VirtualBox, or
whatever) and run some adaptation of setup-node, and setup a file
server to make editing files easy, and then upload the application
(version control files and everything).

To make it more awesome, a built-in web app for managing the image;
checking in files, restarting, tooling, etc.  Maybe the image could be
run headless then?  This is more ambitious, but it could in some way
be an introduction to good open source development practices.

Test-Before-Activate
--------------------

There should be a kind of "check functions are go" URL or command,
similar to how ``update_fetch`` works.  This would be fetched on
update, but before the update was really made live (the internal
request mechanism can be run on any instance, even one that is not
live yet).  If this returned a non-2xx result, then the update would
be aborted.

Backup/Restore/Revert on update
-------------------------------

Each update is a point when a persistence checkpoint should happen.
This is most easily done with a local backup.

There should also be a "run all database updates" URL (also similar to
``update_fetch``).  This might fail, in which case the backup should
be restored and the update aborted.

I'm not sure if this should be the same as the test-before-activate
URL, or if not whether it should be run before or after.

Debugging
---------

I'm fairly conflicted about what toppcloud should do with respect to
debugging.  I am inclined to say that applications should be
instrumented with debugging tools natively, e.g., using Django's
built-in tools or weberror, etc.

On the other hand, without this kind of wrapping you get something
that really sucks -- normal Apache error logs.  Maybe at least
``environ['wsgi.errors']`` should be fixed (along with stderr) to
point to something better/reasonable.

Setting up the ``logging`` module is somewhat similar.

Also there should be centralized configuration of things like, e.g.,
where error messages are sent.  Then tools could be configured in a
more transportable way (e.g., ``DEBUG_EMAIL =
os.environ['TOPPCLOUD_DEBUG_EMAIL']``).

Unify Environment Setup
-----------------------

Environment setup happens in some scripts (like ``master_runner.py``
and ``internal-request.py``) and in other places like
``lib/python2.6/sitecustomize.py``).  These should all work exactly
the same.

As a result the environment should become more command-line-program
friendly.  Probably most places where URLs are fetched could also
accept program invocations (e.g., ``django-admin.py syncdb``).  I kind
of like using requests... but I also realize there's little reason to
*require* them in this system, so the constraint really doesn't have
to exist.

Some of the monitoring mod_wsgi provides would be nice to (optionally)
provide to command-line scripts.  Like, if a script stalls out it
should be killed.  Maybe.  At least for cron jobs or something.

Cron and Tasks
--------------

App Engine style cronjobs and tasks are definitely planned.

Cron jobs are based on requests run periodically.  Though I guess they
could also be commands.  One advantage of keeping to requests is to
have some kind of monitoring for failed or rejected requests (though
the internal request mechanism is not as robust currently as the
external request system, which is managed by mod_wsgi).

Tasks are things to be done in the future, asynchronously with any
request.  These are queued, get retried in cases of failure (non-2xx
response); maybe given multiple servers they could be run on different
servers.

Cron is a higher priority.

Configuration
-------------

I'm not even sure what this *means*, but I know it needs to be
implemented in some way.  I'm kind of holding off because I don't want
apps/servers to get configured a lot.  But for reusable application
packages *something* has to be implemented.  And I suspect there are
places where this is really sensible.

I will probably resist this until it is clear what it should mean.

API Keys
--------

This is the obvious kind of non-portable configuration.  There is some
support for this already, but it is poorly exposed.

This is something that might be good to manage organization-wide.
Which just makes the workflow slightly different.

Writable Static Files
---------------------

Right now there's not really a way to manage static files.  This is
kind of weird to me because Sphinx makes nice static files, and I
can't actually host them with toppcloud.

I can't quite figure out how this would work, except I guess you might
define something in ``app.ini`` like::

    writable_static_files =
        /foo
        /bar

And then there would be environmental variables to give the file paths
of those locations.  It's kind of structured, so fitting it into an
environmental variable is kind of awkward.  It's similar to
``service.files``, just visible files.

If you are hosting non-public files, then
``environ['wsgi.file_wrapper']`` will remain the better option, and
can be achieved currently with ``service.files``.

Per-path applications
---------------------

Right now an application is only associated with a hostname.  Isolated
and independent applications should be possible with a path (e.g.,
upload an application to ``example.com/blog/``).  This will require
changes to the hostmap (probably writing some `mapping code
<http://httpd.apache.org/docs/2.2/mod/mod_rewrite.html#rewritemap>`_
in Python to be run by Apache).

Inter-application communication
-------------------------------

This will only happen with a strong use case to motivate it; I can
certainly *imagine* such use cases, but I need something more concrete
than my imagination.

In that case, an application could receive configuration information
for other applications.  Communication would have to be through some
service (e.g., a database) or HTTP.  Applications on other hosts would
probably not be supported, but given per-path applications it is
reasonable to consider cases where this would be useful.  Auth is an
obvious case.

The toppcloud secret is currently per-server (and will probably be
per-group in the future), so some things like reading cookies could be
done across applications already (given the appropriate code).

Testing and Test Fixture Setup
------------------------------

It would be nice to have a nice setup for getting test data setup.  I
think some degree of testing support would be nice, though simply
installing and using a standard test runner seems mostly fine.  A
recipe for integration testing would be nice.  A recipe for full-stack
testing (e.g., with Windmill or Selenium) would be nice.  These are
probably more recipes than core toppcloud things.

